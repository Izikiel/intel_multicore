/*
 * Copyright (c) 2013 ETH Zurich. All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, CAB F.78, Universitaetstr. 6, CH-8092 Zurich,
 * Attn: Systems Group.
 */

/*
 * omap44xx_sdma.dev
 *
 * DESCRIPTION: 
 *
 * NOTE: This file has been automatically generated based on the
 * XML files extracted from the TI RDT v1.0.0.4p Tool.
 * Download from here: http://www.ti.com/product/omap4460
 * This means that the file might not be optimal in terms of naming
 * conventions for constants and registers (duplicated
 * namespaces in register and device name etc.).
 * Also, because of the underlying structure from the original XML
 * it's possible that some constants appear multiple times (if they
 * have slightly different descriptions for example).
 *
 * You want to clean that up before using the files for the first time!
 */
 
device omap44xx_sdma msbfirst ( addr base ) "" {
    
    
    register dma4_revision ro addr(base, 0x0) "This register contains the DMA revision code" type(uint32);
    
    register dma4_irqstatus_lj_0 rw addr(base, 0x8) "The interrupt status register regroups all the status of the DMA4 channels that can generate an interrupt over line Lj." type(uint32);
    
    register dma4_irqstatus_lj_1 rw addr(base, 0xC) "The interrupt status register regroups all the status of the DMA4 channels that can generate an interrupt over line Lj." type(uint32);
    
    register dma4_irqstatus_lj_2 rw addr(base, 0x10) "The interrupt status register regroups all the status of the DMA4 channels that can generate an interrupt over line Lj." type(uint32);
    
    register dma4_irqstatus_lj_3 rw addr(base, 0x14) "The interrupt status register regroups all the status of the DMA4 channels that can generate an interrupt over line Lj." type(uint32);
    
    register dma4_irqenable_lj_0 rw addr(base, 0x18) "The interrupt enable register allows to mask/unmask the module internal sources of interrupt, on line Lj" type(uint32);
    
    register dma4_irqenable_lj_1 rw addr(base, 0x1C) "The interrupt enable register allows to mask/unmask the module internal sources of interrupt, on line Lj" type(uint32);
    
    register dma4_irqenable_lj_2 rw addr(base, 0x20) "The interrupt enable register allows to mask/unmask the module internal sources of interrupt, on line Lj" type(uint32);
    
    register dma4_irqenable_lj_3 rw addr(base, 0x24) "The interrupt enable register allows to mask/unmask the module internal sources of interrupt, on line Lj" type(uint32);

    constants resetdone_status width(1) "" {
        RESETDONE_0_r = 0 "Internal module reset is on-going";
        RESETDONE_1_r = 1 "Reset completed";
    };
    
    register dma4_sysstatus addr(base, 0x28) "The register provides status information about the module excluding the interrupt status information (see interrupt status register)" {
        _ 31 mbz;
        resetdone 1 ro type(resetdone_status) "Internal reset monitoring";
    };

    constants midlemode_status width(2) "" {
        MIDLEMODE_0 = 0 "Force-standby: MStandby is asserted only when all the DMA channels are disabled";
        MIDLEMODE_1 = 1 "No-Standby: MStandby is never asserted";
        MIDLEMODE_2 = 2 "Smart-Standby: MStandby is asserted if at least one of the following two conditions is satisfied: 1. All the channels are disabled, OR 2. There is no non-synchronized channel enabled AND [if hardware synchronized channel is enabled, then no DMA request input is asserted and no requests are pending to be serviced].";
        MIDLEMODE_3 = 3 "Reserved";
    };

    constants emufree_status width(1) "" {
        EMUFREE_0 = 0 "DMA4 freezes its internal logic upon MSuspend assertion";
        EMUFREE_1 = 1 "DMA4 ignores the MSuspend input";
    };

    constants sidlemode_status width(2) "" {
        SIDLEMODE_0 = 0 "Force-idle. An idle request is acknowledged unconditionally";
        SIDLEMODE_1 = 1 "No-idle. An idle request is never acknowledged";
        SIDLEMODE_2 = 2 "Smart-idle. Idle acknowledge is given by DMA4 if all of the conditions are true: 1. All the channels are disabled. 2. If hardware synchronized channel is enabled, then no DMA request input is asserted and no requests are pending to be serviced. 3. All transactions are completed on all the DMA ports. 4.No interrupts are pending to be serviced.";
        SIDLEMODE_3 = 3 "Reserved. Do not use";
    };

    constants autoidle_status width(1) "" {
        AUTOIDLE_0 = 0 "Interface clock is free running";
        AUTOIDLE_1 = 1 "Automatic interface clock gating strategy is applied, based on the interface activity.";
    };
    
    register dma4_ocp_sysconfig addr(base, 0x2C) "DMA system configuration register" {
        _ 18 mbz;
        midlemode 2 rw type(midlemode_status) "Read write power management, standby/wait control";
        _ 2 mbz;
        clockactivity 2 ro "Clocks activities during wake-up Bit 8: Interface clock 0x0: Interface clock can be switched-off Bit 9: Functional clock 0x0: Functional clock can be switched-off";
        _ 2 mbz;
        emufree 1 rw type(emufree_status) "Enable sensitivity to MSuspend";
        sidlemode 2 rw type(sidlemode_status) "Configuration port power management, Idle req/ack control";
        _ 1 mbz;
        _ 1 mbz;
        autoidle 1 rw type(autoidle_status) "Internal interface clock gating strategy";
    };

    constants const_fill_cpblty_status width(1) "" {
        CONST_FILL_CPBLTY_0_r = 0 "No LCH supports constant fill copy";
        CONST_FILL_CPBLTY_1_r = 1 "any LCH supports constant fill copy";
    };

    constants transparent_blt_cpblty_status width(1) "" {
        TRANSPARENT_BLT_CPBLTY_0_r = 0 "No LCH supports transparent BLT copy";
        TRANSPARENT_BLT_CPBLTY_1_r = 1 "any LCH supports transparent BLT copy";
    };
    
    register dma4_caps_0 addr(base, 0x64) "DMA Capabilities Register 0 LSW" {
        _ 10 mbz;
        link_list_cpblty_type4 1 ro "Link List capability for type4 descriptor capability";
        link_list_cpblty_type123 1 ro "Link List capability for type123 descriptor capability";
        const_fill_cpblty 1 ro type(const_fill_cpblty_status) "Constant_Fill_Capability";
        transparent_blt_cpblty 1 ro type(transparent_blt_cpblty_status) "Transparent_BLT_Capability";
        _ 18 mbz;
    };

    constants separate_src_and_dst_index_cpblty_status width(1) "" {
        SEPARATE_SRC_AND_DST_INDEX_CPBLTY_0_r = 0 "Does not support separate src/dst index for 2D addressing";
        SEPARATE_SRC_AND_DST_INDEX_CPBLTY_1_r = 1 "Supports separate src/dest index for 2D addressing";
    };
    
    register dma4_caps_2 addr(base, 0x6C) "DMA Capabilities Register 2" {
        _ 23 mbz;
        separate_src_and_dst_index_cpblty 1 ro type(separate_src_and_dst_index_cpblty_status) "Separate_source/destination_index_capability";
        dst_double_index_adrs_cpblty 1 ro type(sidlemode_status) "Destination_double_index_address_capability";
        dst_single_index_adrs_cpblty 1 ro type(sidlemode_status) "Destination_single_index_address_capability";
        dst_post_incrmnt_adrs_cpblty 1 ro type(sidlemode_status) "Destination_post_increment_address_capability";
        dst_const_adrs_cpblty 1 ro type(sidlemode_status) "Destination_constant_address_capability";
        src_double_index_adrs_cpblty 1 ro type(sidlemode_status) "Source_double_index_address_capability";
        src_single_index_adrs_cpblty 1 ro type(sidlemode_status) "Source_single_index_address_capability";
        src_post_increment_adrs_cpblty 1 ro type(sidlemode_status) "Source_post_increment_address_capability";
        src_const_adrs_cpblty 1 ro type(sidlemode_status) "Source_constant_address_capability";
    };

    constants channel_chaninig_cpblty_status width(1) "" {
        CHANNEL_CHANINIG_CPBLTY_0_r = 0 "Does not support Channel Chaninig capability";
        CHANNEL_CHANINIG_CPBLTY_1_r = 1 "Supports Channel Chaninig capability";
    };

    constants channel_interleave_cpblty_status width(1) "" {
        CHANNEL_INTERLEAVE_CPBLTY_0_r = 0 "Does not support Channel interleave capability";
        CHANNEL_INTERLEAVE_CPBLTY_1_r = 1 "Supports Channel_interleave capability";
    };
    
    register dma4_caps_3 addr(base, 0x70) "DMA Capabilities Register 3" {
        _ 24 mbz;
        block_synchr_cpblty 1 ro type(sidlemode_status) "Block_synchronization_capability";
        pkt_synchr_cpblty 1 ro type(sidlemode_status) "Packet_synchronization_capability";
        channel_chaninig_cpblty 1 ro type(channel_chaninig_cpblty_status) "Channel_Chaninig_capability";
        channel_interleave_cpblty 1 ro type(channel_interleave_cpblty_status) "Channel_interleave_capability";
        _ 2 mbz;
        frame_synchr_cpblty 1 ro type(sidlemode_status) "Frame_synchronization_capability";
        elmnt_synchr_cpblty 1 ro type(sidlemode_status) "Element_synchronization_capability";
    };
    
    register dma4_caps_4 addr(base, 0x74) "DMA Capabilities Register 4" {
        _ 17 mbz;
        eosb_interrupt_cpblty 1 ro "End of Super Block detection capability.";
        _ 1 rsvd;
        drain_end_interrupt_cpblty 1 ro "Drain End detection capability.";
        misaligned_adrs_err_interrupt_cpblty 1 ro "Misaligned error detection capability.";
        supervisor_err_interrupt_cpblty 1 ro "Supervisor error detection capability.";
        _ 1 rsvd;
        trans_err_interrupt_cpblty 1 ro "Transaction error detection capability.";
        pkt_interrupt_cpblty 1 ro type(sidlemode_status) "End of Packet detection capability.";
        sync_status_cpblty 1 ro type(sidlemode_status) "Sync_status_capability";
        block_interrupt_cpblty 1 ro type(sidlemode_status) "End of block detection capability.";
        last_frame_interrupt_cpblty 1 ro type(sidlemode_status) "Start of last frame detection capability.";
        frame_interrupt_cpblty 1 ro type(sidlemode_status) "End of frame detection capability.";
        half_frame_interrupt_cpblty 1 ro type(sidlemode_status) "Detection capability of the half of frame end.";
        event_drop_interrupt_cpblty 1 ro type(sidlemode_status) "Request collision detection capability.";
        _ 1 mbz;
    };

    constants hi_lo_fifo_budget_status width(2) "" {
        HI_LO_FIFO_BUDGET_0 = 0 "no fixed budget for neither higher nor lower priority channel";
        HI_LO_FIFO_BUDGET_1 = 1 "75% of FIFO for low priority and 25% for high priority channels";
        HI_LO_FIFO_BUDGET_2 = 2 "25% of FIFO for low priority and 75% for high priority channels";
        HI_LO_FIFO_BUDGET_3 = 3 "50% of FIFO for low priority and 50% for high priority channels";
    };

    constants hi_thread_reserved_status width(2) "" {
        HI_THREAD_RESERVED_0 = 0 "No ThreadID is reserved on the Read Port for high priority channels. No ThreadID is reserved on the Write Port for high priority channels.";
        HI_THREAD_RESERVED_1 = 1 "Read Port ThreadID 0 is reserved for high priority channels. Write Port ThreadID 0 is reserved for high priority channels.";
        HI_THREAD_RESERVED_2 = 2 "Read port ThreadID 0 and ThreadID 1 are reserved for high priority channels. Write Port ThreadID 0 is reserved for high priority channels.";
        HI_THREAD_RESERVED_3 = 3 "Read PortThreadID 0, ThreadID 1 and ThreadID 2 are reserved for high priority channels. Write Port ThreadID 0 is reserved for high priority channels.";
    };
    
    register dma4_gcr addr(base, 0x78) "" {
        _ 7 mbz;
        channel_id_gate 1 rw "Gates the Channel ID bus monitoring on both Read and Write ports 0x0: Gates the Channel ID qualifiers on both Read and Write Ports 0x1: Does not gate the Channel ID qualifiers on both Read and Write Ports";
        arbitration_rate 8 rw "Arbitration switching rate between prioritized and regular channel queues";
        hi_lo_fifo_budget 2 rw type(hi_lo_fifo_budget_status) "Allow to have a separate Global FIFO budget for high and low priority channels. For Hi priority Channel: (Per_channel_Maximum FIFO depth + 1) x Number of active High priority Channel &amp;lt;= High Budget FIFO For Low priority channel: (Per_channel_Maximum FIFO depth + 1) x Number of active Low priority Channel &amp;lt;= Low Budget FIFO";
        hi_thread_reserved 2 rw type(hi_thread_reserved_status) "Allow thread reservation for high priority channel on both read and write ports.";
        _ 4 mbz;
        max_channel_fifo_depth 8 rw "Maximum FIFO depth allocated to one logical channel. Maximum FIFO depth can not be 0x0. It should be at least 0x1 or greater. Note that If channel limit is less than destination burst size enough data will not be accumulated in the data FIFO and it will never be sent out on the WR port. The burst size should be less than the FIFO limit specified in this bit field.";
    };

    constants sel_src_dst_sync_status width(1) "" {
        SEL_SRC_DST_SYNC_0 = 0 "Transfer is triggered by the destination. If synch on packet the packet element number is specified in the CDFI register.";
        SEL_SRC_DST_SYNC_1 = 1 "Transfer is triggered by the source. If synchronized on packet the packet element number is specified in the CSFI register.";
    };

    constants prefetch_status width(1) "" {
        PREFETCH_0 = 0 "Prefetch mode is disabled. When Sel_Src_Dst_Sync=1 transfers are buffered and pipelined between DMA requests.";
        PREFETCH_1 = 1 "Prefetch mode is enabled. Prefetch mode is active only when destination is synchronized. It is software user responsibility not to have at the same time Prefetch=1 when Sel_Src_Dst_Sync=1. This mode is not supported.";
    };

    constants supervisor_status width(1) "" {
        SUPERVISOR_0 = 0 "Supervisor mode is disabled.";
        SUPERVISOR_1 = 1 "Supervisor mode is enabled.";
    };

    constants transparent_copy_enable_status width(1) "" {
        TRANSPARENT_COPY_ENABLE_0 = 0 "Transparent copy mode is disabled.";
        TRANSPARENT_COPY_ENABLE_1 = 1 "Transparent copy mode is enabled.";
    };

    constants const_fill_enable_status width(1) "" {
        CONST_FILL_ENABLE_0 = 0 "Constant fill mode is disabled.";
        CONST_FILL_ENABLE_1 = 1 "Constant fill mode is enabled.";
    };

    constants dst_amode_status width(2) "" {
        DST_AMODE_0 = 0 "Constant address mode";
        DST_AMODE_1 = 1 "Post-incremented address mode";
        DST_AMODE_2 = 2 "Single index address mode";
        DST_AMODE_3 = 3 "Double index address mode";
    };

    constants rd_active_status width(1) "" {
        RD_ACTIVE_0_r = 0 "Channel is not active on the read port.";
        RD_ACTIVE_1_r = 1 "Channel is currently active on the read port.";
    };

    constants suspend_sensitive_status width(1) "" {
        SUSPEND_SENSITIVE_0 = 0 "The channel ignores the MSuspend even if EMUFree is set to 0.";
        SUSPEND_SENSITIVE_1 = 1 "If EMUFree is set to 0 and MSuspend comes in then all current OCP services (single transaction or burst transaction as specified in the corresponding CSDP register) have to be completed before stopping processing any more transactions.";
    };

    constants enable_status width(1) "" {
        ENABLE_0 = 0 "The logical channel is disabled.";
        ENABLE_1 = 1 "The logical channel is enabled.";
    };
    
    register dma4_ccri_0 addr(base, 0x80) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_1 addr(base, 0xE0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_2 addr(base, 0x140) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_3 addr(base, 0x1A0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_4 addr(base, 0x200) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_5 addr(base, 0x260) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_6 addr(base, 0x2C0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_7 addr(base, 0x320) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_8 addr(base, 0x380) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_9 addr(base, 0x3E0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_10 addr(base, 0x440) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_11 addr(base, 0x4A0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_12 addr(base, 0x500) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_13 addr(base, 0x560) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_14 addr(base, 0x5C0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_15 addr(base, 0x620) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_16 addr(base, 0x680) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_17 addr(base, 0x6E0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_18 addr(base, 0x740) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_19 addr(base, 0x7A0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_20 addr(base, 0x800) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_21 addr(base, 0x860) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_22 addr(base, 0x8C0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_23 addr(base, 0x920) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_24 addr(base, 0x980) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_25 addr(base, 0x9E0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_26 addr(base, 0xA40) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_27 addr(base, 0xAA0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_28 addr(base, 0xB00) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_29 addr(base, 0xB60) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_30 addr(base, 0xBC0) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_ccri_31 addr(base, 0xC20) "Channel Control Register" {
        _ 2 mbz;
        _ 3 mbz;
        write_priority 1 rw type(sidlemode_status) "Channel priority on the Write side";
        buffering_disable 1 rw type(sidlemode_status) "This bit allows to disable the default buffering functionality when transfer is source synchronized.";
        sel_src_dst_sync 1 rw type(sel_src_dst_sync_status) "Specifies that element, packet, frame or block transfer (depending on CCR.bs and CCR.fs) is triggered by the source or the destination on the DMA request";
        prefetch 1 rw type(prefetch_status) "Enables the prefetch mode";
        supervisor 1 rw type(supervisor_status) "Enables the supervisor mode";
        _ 1 mbz;
        synchro_control_upper 2 rw "Channel Synchronization control upper (used in conjunction with the 5 bits of synchro channelDMA4_CCRi[4:0]) Used in conjunction, as 2 MSB, with the 5 bits of the synchro channel bit field.";
        bs 1 rw "Block synchronization This bit used in conjunction with the fs to see how the DMA request is serviced in a synchronized transfer.";
        transparent_copy_enable 1 rw type(transparent_copy_enable_status) "Transparent copy enable";
        const_fill_enable 1 rw type(const_fill_enable_status) "Constant fill enable";
        dst_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Write Port of a channel.";
        src_amode 2 rw type(dst_amode_status) "Selects the addressing mode on the Read Port of a channel.";
        _ 1 mbz;
        wr_active 1 ro type(sidlemode_status) "Indicates if the channel write context is active or not";
        rd_active 1 ro type(rd_active_status) "Indicates if the channel read context is active or not";
        suspend_sensitive 1 rw type(suspend_sensitive_status) "Logical channel suspend enable bit";
        enable 1 rw type(enable_status) "Logical channel enable. It is SW responsibility to clear the CSR register and the IRQSTATUS bit for the different interrupt lines before enabling the channel.";
        read_priority 1 rw type(sidlemode_status) "Channel priority on the read side";
        fs 1 rw "Frame synchronization This bit used in conjunction with the BS to see how the DMA request is serviced in a synchronized transfer FS = 0 and BS = 0: An element is transferred once a DMA request is made. FS = 0 and BS = 1: An entire block is transferred once a DMA request is made. FS = 1 and BS = 0: An entire frame is transferred once a DMA request is made. FS = 1 and BS = 1: A packet is transferred once a DMA request is made. All these different transfers can be interleaved on the port with other DMA requests.";
        synchro_control 5 rw "Channel synchronization control This bit field used in conjunction with the second_level_ synchro_control_upper (as 2 MSB) 0000000 : Is reserved for non synchronized LCH transfer xxxxxxx (from 1 to 127)There are 127 possible DMA request to assign to any LCH. The channel synchronization control registers are 1-based. For example, to enable the S_DMA_1 request, DMA4_CCR[4:0] SYNCHRO_CONTROL must be set to 0x2 (DMA request number + 1).";
    };
    
    register dma4_clnk_ctrli_0 addr(base, 0x84) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_1 addr(base, 0xE4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_2 addr(base, 0x144) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_3 addr(base, 0x1A4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_4 addr(base, 0x204) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_5 addr(base, 0x264) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_6 addr(base, 0x2C4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_7 addr(base, 0x324) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_8 addr(base, 0x384) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_9 addr(base, 0x3E4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_10 addr(base, 0x444) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_11 addr(base, 0x4A4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_12 addr(base, 0x504) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_13 addr(base, 0x564) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_14 addr(base, 0x5C4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_15 addr(base, 0x624) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_16 addr(base, 0x684) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_17 addr(base, 0x6E4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_18 addr(base, 0x744) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_19 addr(base, 0x7A4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_20 addr(base, 0x804) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_21 addr(base, 0x864) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_22 addr(base, 0x8C4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_23 addr(base, 0x924) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_24 addr(base, 0x984) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_25 addr(base, 0x9E4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_26 addr(base, 0xA44) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_27 addr(base, 0xAA4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_28 addr(base, 0xB04) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_29 addr(base, 0xB64) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_30 addr(base, 0xBC4) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };
    
    register dma4_clnk_ctrli_31 addr(base, 0xC24) "Channel Link Control Register" {
        _ 16 mbz;
        enable_lnk 1 rw type(sidlemode_status) "Enables or disable the channel linking.";
        _ 10 mbz;
        nextlch_id 5 rw "Defines the NextLCh_ID, which is used to build logical channel chaining queue.";
    };

    constants block_ie_status width(1) "" {
        BLOCK_IE_0 = 0 "Disables the end of block interrupt";
        BLOCK_IE_1 = 1 "Disables the end of block interrupt";
    };

    constants last_ie_status width(1) "" {
        LAST_IE_0 = 0 "Disables the last frame interrupt";
        LAST_IE_1 = 1 "Enables the last frame interrupt";
    };

    constants frame_ie_status width(1) "" {
        FRAME_IE_0 = 0 "Disables the end of frame interrupt";
        FRAME_IE_1 = 1 "Enables the end of frame interrupt";
    };

    constants half_ie_status width(1) "" {
        HALF_IE_0 = 0 "Disables the half frame interrupt";
        HALF_IE_1 = 1 "Enables the half frame interrupt";
    };

    constants drop_ie_status width(1) "" {
        DROP_IE_0 = 0 "Disables the event drop interrupt";
        DROP_IE_1 = 1 "Enables the event drop interrupt";
    };
    
    register dma4_cicri_0 addr(base, 0x88) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(sidlemode_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(sidlemode_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(sidlemode_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(sidlemode_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_1 addr(base, 0xE8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_2 addr(base, 0x148) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_3 addr(base, 0x1A8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_4 addr(base, 0x208) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_5 addr(base, 0x268) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_6 addr(base, 0x2C8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_7 addr(base, 0x328) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_8 addr(base, 0x388) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_9 addr(base, 0x3E8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_10 addr(base, 0x448) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_11 addr(base, 0x4A8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_12 addr(base, 0x508) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_13 addr(base, 0x568) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_14 addr(base, 0x5C8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_15 addr(base, 0x628) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_16 addr(base, 0x688) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_17 addr(base, 0x6E8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_18 addr(base, 0x748) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_19 addr(base, 0x7A8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_20 addr(base, 0x808) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_21 addr(base, 0x868) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_22 addr(base, 0x8C8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_23 addr(base, 0x928) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_24 addr(base, 0x988) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_25 addr(base, 0x9E8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_26 addr(base, 0xA48) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_27 addr(base, 0xAA8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_28 addr(base, 0xB08) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_29 addr(base, 0xB68) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_30 addr(base, 0xBC8) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };
    
    register dma4_cicri_31 addr(base, 0xC28) "Channel Interrupt Control Register" {
        _ 17 mbz;
        super_block_ie 1 rw "Enables the end of super block interrupt";
        _ 1 rsvd;
        drain_ie 1 rw "Enables the end of draining interrupt";
        misaligned_err_ie 1 rw type(hi_thread_reserved_status) "Enables the address misaligned error event interrupt";
        supervisor_err_ie 1 rw type(hi_thread_reserved_status) "Enables the supervisor transaction error event interrupt";
        _ 1 rsvd;
        trans_err_ie 1 rw type(hi_thread_reserved_status) "Enables the transaction error event interrupt";
        pkt_ie 1 rw type(hi_thread_reserved_status) "Enables the end of Packet interrupt";
        _ 1 mbz;
        block_ie 1 rw type(block_ie_status) "Enables the end of block interrupt";
        last_ie 1 rw type(last_ie_status) "Last frame interrupt enable (start of last frame)";
        frame_ie 1 rw type(frame_ie_status) "Frame interrupt enable (end of frame)";
        half_ie 1 rw type(half_ie_status) "Enables or disables the half frame interrupt.";
        drop_ie 1 rw type(drop_ie_status) "Synchronization event drop interrupt enable (request collision)";
        _ 1 mbz;
    };

    constants misaligned_adrs_err_status width(1) "" {
        MISALIGNED_ADRS_ERR_0_r = 0 "No address error";
        MISALIGNED_ADRS_ERR_0_w = 0 "Status bit unchanged";
        MISALIGNED_ADRS_ERR_1_w = 1 "Status bit is reset";
        MISALIGNED_ADRS_ERR_1_r = 1 "An address error has been occurred";
    };

    constants supervisor_err_status width(1) "" {
        SUPERVISOR_ERR_0_r = 0 "No supervisor transaction error";
        SUPERVISOR_ERR_0_w = 0 "Status bit unchanged";
        SUPERVISOR_ERR_1_w = 1 "Status bit is reset";
        SUPERVISOR_ERR_1_r = 1 "A supervisor transaction error has been occurred";
    };

    constants trans_err_status width(1) "" {
        TRANS_ERR_0_r = 0 "No transaction error";
        TRANS_ERR_0_w = 0 "Status bit unchanged";
        TRANS_ERR_1_w = 1 "Status bit is reset";
        TRANS_ERR_1_r = 1 "A transaction error has been occurred";
    };

    constants pkt_status width(1) "" {
        PKT_0_r = 0 "The current packet transfer has not been finished";
        PKT_0_w = 0 "Status bit unchanged";
        PKT_1_w = 1 "Status bit is reset";
        PKT_1_r = 1 "The current packet has been transferred";
    };

    constants sync_status width(1) "" {
        SYNC_0_r = 0 "Logical channel is not scheduled or servicing a non synchronized DMA request.";
        SYNC_0_w = 0 "Status bit unchanged";
        SYNC_1_w = 1 "Status bit is reset";
        SYNC_1_r = 1 "Logical channel is servicing a synchronized DMA request";
    };

    constants block_status width(1) "" {
        BLOCK_0_r = 0 "The current block transfer has not been finished";
        BLOCK_0_w = 0 "Status bit unchanged";
        BLOCK_1_w = 1 "Status bit is reset";
        BLOCK_1_r = 1 "The current block has been transferred";
    };

    constants last_status width(1) "" {
        LAST_0_r = 0 "The start of the last frame to transfer is not reached";
        LAST_0_w = 0 "Status bit unchanged";
        LAST_1_w = 1 "Status bit is reset";
        LAST_1_r = 1 "The start of the last frame to transfer is reached";
    };

    constants drop_status width(1) "" {
        DROP_0_r = 0 "No synchronization collision";
        DROP_0_w = 0 "Status bit unchanged";
        DROP_1_w = 1 "Status bit is reset";
        DROP_1_r = 1 "A synchronization collision has been occurred";
    };
    
    register dma4_csri_0 addr(base, 0x8C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_1 addr(base, 0xEC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_2 addr(base, 0x14C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_3 addr(base, 0x1AC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_4 addr(base, 0x20C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_5 addr(base, 0x26C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_6 addr(base, 0x2CC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_7 addr(base, 0x32C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_8 addr(base, 0x38C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_9 addr(base, 0x3EC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_10 addr(base, 0x44C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_11 addr(base, 0x4AC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_12 addr(base, 0x50C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_13 addr(base, 0x56C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_14 addr(base, 0x5CC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_15 addr(base, 0x62C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_16 addr(base, 0x68C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_17 addr(base, 0x6EC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_18 addr(base, 0x74C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_19 addr(base, 0x7AC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_20 addr(base, 0x80C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_21 addr(base, 0x86C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_22 addr(base, 0x8CC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_23 addr(base, 0x92C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_24 addr(base, 0x98C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_25 addr(base, 0x9EC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_26 addr(base, 0xA4C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_27 addr(base, 0xAAC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_28 addr(base, 0xB0C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_29 addr(base, 0xB6C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_30 addr(base, 0xBCC) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };
    
    register dma4_csri_31 addr(base, 0xC2C) "Channel Status Register" {
        _ 15 mbz;
        _ 2 mbz;
        super_block 1 rw "End of Super block event";
        _ 1 mbz;
        drain_end 1 rw "End of channel draining";
        misaligned_adrs_err 1 rw type(misaligned_adrs_err_status) "Misaligned address error event";
        supervisor_err 1 rw type(supervisor_err_status) "Supervisor transaction error event";
        _ 1 mbz;
        trans_err 1 rw type(trans_err_status) "Transaction error event";
        pkt 1 rw type(pkt_status) "End of Packet transfer";
        sync 1 rw type(sync_status) "Synchronization status of a channel.";
        block 1 rw type(block_status) "End of block event";
        last 1 rw type(last_status) "Last frame (start of last frame)";
        frame 1 rw type(last_status) "End of frame event";
        half 1 rw type(last_status) "Half of frame event.";
        drop 1 rw type(drop_status) "Synchronization event drop occured during the transfer";
        _ 1 mbz;
    };

    constants src_endian_status width(1) "" {
        SRC_ENDIAN_0 = 0 "Source has Little Endian type";
        SRC_ENDIAN_1 = 1 "Source has Big Endian type";
    };

    constants src_endian_lock_status width(1) "" {
        SRC_ENDIAN_LOCK_0 = 0 "Endianness adapt";
        SRC_ENDIAN_LOCK_1 = 1 "Endianness lock";
    };

    constants dst_endian_status width(1) "" {
        DST_ENDIAN_0 = 0 "Destination has Little Endian type";
        DST_ENDIAN_1 = 1 "Destination has Big Endian type";
    };

    constants write_mode_status width(2) "" {
        WRITE_MODE_0 = 0 "Write None Posted (WRNP)";
        WRITE_MODE_1 = 1 "Write (Posted)";
        WRITE_MODE_2 = 2 "All transaction are mapped on the Write command as posted except for the last transaction in the transfer mapped on a Write None Posted";
        WRITE_MODE_3 = 3 "Undefined";
    };

    constants dst_burst_en_status width(2) "" {
        DST_BURST_EN_0 = 0 "single access";
        DST_BURST_EN_1 = 1 "16 bytes or 4x32-bit / 2x64-bit burst access";
        DST_BURST_EN_2 = 2 "32 bytes or 8x32-bit / 4x64-bit burst access";
        DST_BURST_EN_3 = 3 "64 bytes or 16x32-bit / 8x64-bit burst access";
    };

    constants dst_packed_status width(1) "" {
        DST_PACKED_0 = 0 "The destination target is non packed";
        DST_PACKED_1 = 1 "The destination target is packed";
    };

    constants src_packed_status width(1) "" {
        SRC_PACKED_0 = 0 "The source target is non packed";
        SRC_PACKED_1 = 1 "The source target is packed";
    };

    constants data_type_status width(2) "" {
        DATA_TYPE_0 = 0 "8 bits scalar";
        DATA_TYPE_1 = 1 "16 bits scalar";
        DATA_TYPE_2 = 2 "32 bits scalar";
        DATA_TYPE_3 = 3 "Reserved";
    };
    
    register dma4_csdpi_0 addr(base, 0x90) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_1 addr(base, 0xF0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_2 addr(base, 0x150) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_3 addr(base, 0x1B0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_4 addr(base, 0x210) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_5 addr(base, 0x270) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_6 addr(base, 0x2D0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_7 addr(base, 0x330) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_8 addr(base, 0x390) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_9 addr(base, 0x3F0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_10 addr(base, 0x450) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_11 addr(base, 0x4B0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_12 addr(base, 0x510) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_13 addr(base, 0x570) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_14 addr(base, 0x5D0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_15 addr(base, 0x630) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_16 addr(base, 0x690) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_17 addr(base, 0x6F0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_18 addr(base, 0x750) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_19 addr(base, 0x7B0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_20 addr(base, 0x810) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_21 addr(base, 0x870) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_22 addr(base, 0x8D0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_23 addr(base, 0x930) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_24 addr(base, 0x990) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_25 addr(base, 0x9F0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_26 addr(base, 0xA50) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_27 addr(base, 0xAB0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_28 addr(base, 0xB10) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_29 addr(base, 0xB70) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_30 addr(base, 0xBD0) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_csdpi_31 addr(base, 0xC30) "Channel Source Destination Parameters" {
        _ 10 mbz;
        src_endian 1 rw type(src_endian_status) "Channel source endianness control";
        src_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        dst_endian 1 rw type(dst_endian_status) "Channel Destination endianness control";
        dst_endian_lock 1 rw type(src_endian_lock_status) "Endianness Lock";
        write_mode 2 rw type(write_mode_status) "Used to enable writing mode without posting or with posting";
        dst_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Write Port. Smaller burst size than the programmed burst size is also allowed";
        dst_packed 1 rw type(dst_packed_status) "Destination receives packed data.";
        _ 4 rsvd;
        src_burst_en 2 rw type(dst_burst_en_status) "Used to enable bursting on the Read Port. Smaller burst size than the programmed burst size is also allowed";
        src_packed 1 rw type(src_packed_status) "Source provides packed data.";
        _ 4 rsvd;
        data_type 2 rw type(data_type_status) "Defines the type of the data moved in the channel.";
    };
    
    register dma4_ceni_0 addr(base, 0x94) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_1 addr(base, 0xF4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_2 addr(base, 0x154) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_3 addr(base, 0x1B4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_4 addr(base, 0x214) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_5 addr(base, 0x274) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_6 addr(base, 0x2D4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_7 addr(base, 0x334) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_8 addr(base, 0x394) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_9 addr(base, 0x3F4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_10 addr(base, 0x454) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_11 addr(base, 0x4B4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_12 addr(base, 0x514) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_13 addr(base, 0x574) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_14 addr(base, 0x5D4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_15 addr(base, 0x634) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_16 addr(base, 0x694) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_17 addr(base, 0x6F4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_18 addr(base, 0x754) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_19 addr(base, 0x7B4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_20 addr(base, 0x814) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_21 addr(base, 0x874) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_22 addr(base, 0x8D4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_23 addr(base, 0x934) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_24 addr(base, 0x994) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_25 addr(base, 0x9F4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_26 addr(base, 0xA54) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_27 addr(base, 0xAB4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_28 addr(base, 0xB14) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_29 addr(base, 0xB74) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_30 addr(base, 0xBD4) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_ceni_31 addr(base, 0xC34) "Channel Element Number" {
        _ 8 mbz;
        channel_elmnt_nbr 24 rw "Number of elements within a frame (unsigned) to transfer";
    };
    
    register dma4_cfni_0 addr(base, 0x98) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_1 addr(base, 0xF8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_2 addr(base, 0x158) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_3 addr(base, 0x1B8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_4 addr(base, 0x218) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_5 addr(base, 0x278) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_6 addr(base, 0x2D8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_7 addr(base, 0x338) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_8 addr(base, 0x398) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_9 addr(base, 0x3F8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_10 addr(base, 0x458) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_11 addr(base, 0x4B8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_12 addr(base, 0x518) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_13 addr(base, 0x578) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_14 addr(base, 0x5D8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_15 addr(base, 0x638) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_16 addr(base, 0x698) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_17 addr(base, 0x6F8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_18 addr(base, 0x758) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_19 addr(base, 0x7B8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_20 addr(base, 0x818) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_21 addr(base, 0x878) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_22 addr(base, 0x8D8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_23 addr(base, 0x938) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_24 addr(base, 0x998) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_25 addr(base, 0x9F8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_26 addr(base, 0xA58) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_27 addr(base, 0xAB8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_28 addr(base, 0xB18) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_29 addr(base, 0xB78) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_30 addr(base, 0xBD8) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cfni_31 addr(base, 0xC38) "Channel Frame Number" {
        _ 16 mbz;
        channel_frame_nbr 16 rw "Number of frames within the block to be transferred (unsigned)";
    };
    
    register dma4_cssai_0 rw addr(base, 0x9C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_1 rw addr(base, 0xFC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_2 rw addr(base, 0x15C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_3 rw addr(base, 0x1BC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_4 rw addr(base, 0x21C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_5 rw addr(base, 0x27C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_6 rw addr(base, 0x2DC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_7 rw addr(base, 0x33C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_8 rw addr(base, 0x39C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_9 rw addr(base, 0x3FC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_10 rw addr(base, 0x45C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_11 rw addr(base, 0x4BC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_12 rw addr(base, 0x51C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_13 rw addr(base, 0x57C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_14 rw addr(base, 0x5DC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_15 rw addr(base, 0x63C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_16 rw addr(base, 0x69C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_17 rw addr(base, 0x6FC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_18 rw addr(base, 0x75C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_19 rw addr(base, 0x7BC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_20 rw addr(base, 0x81C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_21 rw addr(base, 0x87C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_22 rw addr(base, 0x8DC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_23 rw addr(base, 0x93C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_24 rw addr(base, 0x99C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_25 rw addr(base, 0x9FC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_26 rw addr(base, 0xA5C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_27 rw addr(base, 0xABC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_28 rw addr(base, 0xB1C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_29 rw addr(base, 0xB7C) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_30 rw addr(base, 0xBDC) "Channel Source Start Address" type(uint32);
    
    register dma4_cssai_31 rw addr(base, 0xC3C) "Channel Source Start Address" type(uint32);
    
    register dma4_cdsai_0 rw addr(base, 0xA0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_1 rw addr(base, 0x100) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_2 rw addr(base, 0x160) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_3 rw addr(base, 0x1C0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_4 rw addr(base, 0x220) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_5 rw addr(base, 0x280) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_6 rw addr(base, 0x2E0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_7 rw addr(base, 0x340) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_8 rw addr(base, 0x3A0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_9 rw addr(base, 0x400) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_10 rw addr(base, 0x460) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_11 rw addr(base, 0x4C0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_12 rw addr(base, 0x520) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_13 rw addr(base, 0x580) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_14 rw addr(base, 0x5E0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_15 rw addr(base, 0x640) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_16 rw addr(base, 0x6A0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_17 rw addr(base, 0x700) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_18 rw addr(base, 0x760) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_19 rw addr(base, 0x7C0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_20 rw addr(base, 0x820) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_21 rw addr(base, 0x880) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_22 rw addr(base, 0x8E0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_23 rw addr(base, 0x940) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_24 rw addr(base, 0x9A0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_25 rw addr(base, 0xA00) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_26 rw addr(base, 0xA60) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_27 rw addr(base, 0xAC0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_28 rw addr(base, 0xB20) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_29 rw addr(base, 0xB80) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_30 rw addr(base, 0xBE0) "Channel Destination Start Address" type(uint32);
    
    register dma4_cdsai_31 rw addr(base, 0xC40) "Channel Destination Start Address" type(uint32);
    
    register dma4_cseii_0 addr(base, 0xA4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_1 addr(base, 0x104) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_2 addr(base, 0x164) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_3 addr(base, 0x1C4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_4 addr(base, 0x224) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_5 addr(base, 0x284) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_6 addr(base, 0x2E4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_7 addr(base, 0x344) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_8 addr(base, 0x3A4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_9 addr(base, 0x404) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_10 addr(base, 0x464) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_11 addr(base, 0x4C4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_12 addr(base, 0x524) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_13 addr(base, 0x584) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_14 addr(base, 0x5E4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_15 addr(base, 0x644) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_16 addr(base, 0x6A4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_17 addr(base, 0x704) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_18 addr(base, 0x764) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_19 addr(base, 0x7C4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_20 addr(base, 0x824) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_21 addr(base, 0x884) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_22 addr(base, 0x8E4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_23 addr(base, 0x944) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_24 addr(base, 0x9A4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_25 addr(base, 0xA04) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_26 addr(base, 0xA64) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_27 addr(base, 0xAC4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_28 addr(base, 0xB24) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_29 addr(base, 0xB84) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_30 addr(base, 0xBE4) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_cseii_31 addr(base, 0xC44) "Channel Source Element Index (Signed)" {
        _ 16 mbz;
        channel_src_elmnt_index 16 rw "Channel source element index";
    };
    
    register dma4_csfii_0 rw addr(base, 0xA8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_1 rw addr(base, 0x108) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_2 rw addr(base, 0x168) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_3 rw addr(base, 0x1C8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_4 rw addr(base, 0x228) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_5 rw addr(base, 0x288) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_6 rw addr(base, 0x2E8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_7 rw addr(base, 0x348) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_8 rw addr(base, 0x3A8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_9 rw addr(base, 0x408) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_10 rw addr(base, 0x468) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_11 rw addr(base, 0x4C8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_12 rw addr(base, 0x528) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_13 rw addr(base, 0x588) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_14 rw addr(base, 0x5E8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_15 rw addr(base, 0x648) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_16 rw addr(base, 0x6A8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_17 rw addr(base, 0x708) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_18 rw addr(base, 0x768) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_19 rw addr(base, 0x7C8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_20 rw addr(base, 0x828) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_21 rw addr(base, 0x888) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_22 rw addr(base, 0x8E8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_23 rw addr(base, 0x948) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_24 rw addr(base, 0x9A8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_25 rw addr(base, 0xA08) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_26 rw addr(base, 0xA68) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_27 rw addr(base, 0xAC8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_28 rw addr(base, 0xB28) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_29 rw addr(base, 0xB88) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_30 rw addr(base, 0xBE8) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csfii_31 rw addr(base, 0xC48) "Channel Source Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdeii_0 addr(base, 0xAC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_1 addr(base, 0x10C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_2 addr(base, 0x16C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_3 addr(base, 0x1CC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_4 addr(base, 0x22C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_5 addr(base, 0x28C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_6 addr(base, 0x2EC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_7 addr(base, 0x34C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_8 addr(base, 0x3AC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_9 addr(base, 0x40C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_10 addr(base, 0x46C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_11 addr(base, 0x4CC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_12 addr(base, 0x52C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_13 addr(base, 0x58C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_14 addr(base, 0x5EC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_15 addr(base, 0x64C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_16 addr(base, 0x6AC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_17 addr(base, 0x70C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_18 addr(base, 0x76C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_19 addr(base, 0x7CC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_20 addr(base, 0x82C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_21 addr(base, 0x88C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_22 addr(base, 0x8EC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_23 addr(base, 0x94C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_24 addr(base, 0x9AC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_25 addr(base, 0xA0C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_26 addr(base, 0xA6C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_27 addr(base, 0xACC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_28 addr(base, 0xB2C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_29 addr(base, 0xB8C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_30 addr(base, 0xBEC) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdeii_31 addr(base, 0xC4C) "Channel Destination Element Index (Signed)" {
        _ 16 mbz;
        channel_dst_elmnt_index 16 rw "Channel destination element index";
    };
    
    register dma4_cdfii_0 rw addr(base, 0xB0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_1 rw addr(base, 0x110) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_2 rw addr(base, 0x170) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_3 rw addr(base, 0x1D0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_4 rw addr(base, 0x230) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_5 rw addr(base, 0x290) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_6 rw addr(base, 0x2F0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_7 rw addr(base, 0x350) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_8 rw addr(base, 0x3B0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_9 rw addr(base, 0x410) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_10 rw addr(base, 0x470) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_11 rw addr(base, 0x4D0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_12 rw addr(base, 0x530) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_13 rw addr(base, 0x590) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_14 rw addr(base, 0x5F0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_15 rw addr(base, 0x650) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_16 rw addr(base, 0x6B0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_17 rw addr(base, 0x710) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_18 rw addr(base, 0x770) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_19 rw addr(base, 0x7D0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_20 rw addr(base, 0x830) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_21 rw addr(base, 0x890) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_22 rw addr(base, 0x8F0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_23 rw addr(base, 0x950) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_24 rw addr(base, 0x9B0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_25 rw addr(base, 0xA10) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_26 rw addr(base, 0xA70) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_27 rw addr(base, 0xAD0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_28 rw addr(base, 0xB30) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_29 rw addr(base, 0xB90) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_30 rw addr(base, 0xBF0) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_cdfii_31 rw addr(base, 0xC50) "Channel Destination Frame Index (Signed) or 16-bit Packet size" type(uint32);
    
    register dma4_csaci_0 ro addr(base, 0xB4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_1 ro addr(base, 0x114) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_2 ro addr(base, 0x174) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_3 ro addr(base, 0x1D4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_4 ro addr(base, 0x234) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_5 ro addr(base, 0x294) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_6 ro addr(base, 0x2F4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_7 ro addr(base, 0x354) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_8 ro addr(base, 0x3B4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_9 ro addr(base, 0x414) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_10 ro addr(base, 0x474) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_11 ro addr(base, 0x4D4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_12 ro addr(base, 0x534) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_13 ro addr(base, 0x594) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_14 ro addr(base, 0x5F4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_15 ro addr(base, 0x654) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_16 ro addr(base, 0x6B4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_17 ro addr(base, 0x714) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_18 ro addr(base, 0x774) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_19 ro addr(base, 0x7D4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_20 ro addr(base, 0x834) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_21 ro addr(base, 0x894) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_22 ro addr(base, 0x8F4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_23 ro addr(base, 0x954) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_24 ro addr(base, 0x9B4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_25 ro addr(base, 0xA14) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_26 ro addr(base, 0xA74) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_27 ro addr(base, 0xAD4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_28 ro addr(base, 0xB34) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_29 ro addr(base, 0xB94) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_30 ro addr(base, 0xBF4) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_csaci_31 ro addr(base, 0xC54) "Channel Source Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_0 rw addr(base, 0xB8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_1 rw addr(base, 0x118) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_2 rw addr(base, 0x178) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_3 rw addr(base, 0x1D8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_4 rw addr(base, 0x238) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_5 rw addr(base, 0x298) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_6 rw addr(base, 0x2F8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_7 rw addr(base, 0x358) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_8 rw addr(base, 0x3B8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_9 rw addr(base, 0x418) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_10 rw addr(base, 0x478) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_11 rw addr(base, 0x4D8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_12 rw addr(base, 0x538) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_13 rw addr(base, 0x598) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_14 rw addr(base, 0x5F8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_15 rw addr(base, 0x658) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_16 rw addr(base, 0x6B8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_17 rw addr(base, 0x718) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_18 rw addr(base, 0x778) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_19 rw addr(base, 0x7D8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_20 rw addr(base, 0x838) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_21 rw addr(base, 0x898) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_22 rw addr(base, 0x8F8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_23 rw addr(base, 0x958) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_24 rw addr(base, 0x9B8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_25 rw addr(base, 0xA18) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_26 rw addr(base, 0xA78) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_27 rw addr(base, 0xAD8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_28 rw addr(base, 0xB38) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_29 rw addr(base, 0xB98) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_30 rw addr(base, 0xBF8) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cdaci_31 rw addr(base, 0xC58) "Channel Destination Address Value. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." type(uint32);
    
    register dma4_cceni_0 addr(base, 0xBC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_1 addr(base, 0x11C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_2 addr(base, 0x17C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_3 addr(base, 0x1DC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_4 addr(base, 0x23C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_5 addr(base, 0x29C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_6 addr(base, 0x2FC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_7 addr(base, 0x35C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_8 addr(base, 0x3BC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_9 addr(base, 0x41C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_10 addr(base, 0x47C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_11 addr(base, 0x4DC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_12 addr(base, 0x53C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_13 addr(base, 0x59C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_14 addr(base, 0x5FC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_15 addr(base, 0x65C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_16 addr(base, 0x6BC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_17 addr(base, 0x71C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_18 addr(base, 0x77C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_19 addr(base, 0x7DC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_20 addr(base, 0x83C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_21 addr(base, 0x89C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_22 addr(base, 0x8FC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_23 addr(base, 0x95C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_24 addr(base, 0x9BC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_25 addr(base, 0xA1C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_26 addr(base, 0xA7C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_27 addr(base, 0xADC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_28 addr(base, 0xB3C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_29 addr(base, 0xB9C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_30 addr(base, 0xBFC) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_cceni_31 addr(base, 0xC5C) "Channel Current Transferred Element Number in the current frame. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 8 mbz;
        current_elmnt_nbr 24 rw "Channel current transferred element number in the current frame";
    };
    
    register dma4_ccfni_0 addr(base, 0xC0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_1 addr(base, 0x120) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_2 addr(base, 0x180) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_3 addr(base, 0x1E0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_4 addr(base, 0x240) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_5 addr(base, 0x2A0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_6 addr(base, 0x300) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_7 addr(base, 0x360) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_8 addr(base, 0x3C0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_9 addr(base, 0x420) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_10 addr(base, 0x480) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_11 addr(base, 0x4E0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_12 addr(base, 0x540) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_13 addr(base, 0x5A0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_14 addr(base, 0x600) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_15 addr(base, 0x660) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_16 addr(base, 0x6C0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_17 addr(base, 0x720) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_18 addr(base, 0x780) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_19 addr(base, 0x7E0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_20 addr(base, 0x840) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_21 addr(base, 0x8A0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_22 addr(base, 0x900) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_23 addr(base, 0x960) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_24 addr(base, 0x9C0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_25 addr(base, 0xA20) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_26 addr(base, 0xA80) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_27 addr(base, 0xAE0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_28 addr(base, 0xB40) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_29 addr(base, 0xBA0) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_30 addr(base, 0xC00) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_ccfni_31 addr(base, 0xC60) "Channel Current Transferred Frame Number in the current transfer. User has to access this register only in 32-bit access. If accessed in 8-bit or 16bit data may be corrupted." {
        _ 16 mbz;
        current_frame_nbr 16 rw "Channel current transferred frame number in the current transfer";
    };
    
    register dma4_colori_0 addr(base, 0xC4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_1 addr(base, 0x124) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_2 addr(base, 0x184) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_3 addr(base, 0x1E4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_4 addr(base, 0x244) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_5 addr(base, 0x2A4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_6 addr(base, 0x304) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_7 addr(base, 0x364) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_8 addr(base, 0x3C4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_9 addr(base, 0x424) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_10 addr(base, 0x484) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_11 addr(base, 0x4E4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_12 addr(base, 0x544) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_13 addr(base, 0x5A4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_14 addr(base, 0x604) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_15 addr(base, 0x664) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_16 addr(base, 0x6C4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_17 addr(base, 0x724) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_18 addr(base, 0x784) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_19 addr(base, 0x7E4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_20 addr(base, 0x844) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_21 addr(base, 0x8A4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_22 addr(base, 0x904) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_23 addr(base, 0x964) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_24 addr(base, 0x9C4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_25 addr(base, 0xA24) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_26 addr(base, 0xA84) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_27 addr(base, 0xAE4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_28 addr(base, 0xB44) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_29 addr(base, 0xBA4) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_30 addr(base, 0xC04) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };
    
    register dma4_colori_31 addr(base, 0xC64) "Channel DMA COLOR KEY /SOLID COLOR" {
        _ 8 rsvd;
        ch_blt_frgrnd_color_or_solid_color_ptrn 24 rw "Color key or solid color pattern: The pattern is replicated according to the data type. If the data-type is 8-bit the pattern is replicated 4 times to fill the register in order to enhance processing when data is packed at the graphic module input. The same reasoning for 16-bit data-type.";
    };

    constants fast_status width(1) "" {
        FAST_0 = 0 "No fast-start mode";
        FAST_1 = 1 "Fast-start mode is enabled.";
    };

    constants transfer_mode_status width(2) "" {
        TRANSFER_MODE_0 = 0 "Normal transfer mode is used.";
        TRANSFER_MODE_1 = 1 "Linked-list channel mode for type 1, 2, or 3 descriptor is used.";
        TRANSFER_MODE_2 = 2 "Undefined";
        TRANSFER_MODE_3 = 3 "Undefined";
    };

    constants pause_link_list_status width(1) "" {
        PAUSE_LINK_LIST_0 = 0 "Linked list is active.";
        PAUSE_LINK_LIST_1 = 1 "Linked list is suspended at the boundary of next descriptor loading.";
    };

    constants next_descriptor_type_status width(3) "" {
        NEXT_DESCRIPTOR_TYPE_0 = 0 "Undefined";
        NEXT_DESCRIPTOR_TYPE_1 = 1 "Next descriptor is of type 1.";
        NEXT_DESCRIPTOR_TYPE_2 = 2 "Next descriptor is of type 2.";
        NEXT_DESCRIPTOR_TYPE_3 = 3 "Next descriptor is of type 3.";
        NEXT_DESCRIPTOR_TYPE_4 = 4 "Undefined";
        NEXT_DESCRIPTOR_TYPE_5 = 5 "Undefined";
        NEXT_DESCRIPTOR_TYPE_6 = 6 "Undefined";
        NEXT_DESCRIPTOR_TYPE_7 = 7 "Undefined";
    };

    constants src_valid_status width(2) "" {
        SRC_VALID_0 = 0 "The source address is not present in the next descriptor and continuous incrementing is enabled.";
        SRC_VALID_1 = 1 "The source address must be reloaded in the next descriptor transfer.";
        SRC_VALID_2 = 2 "The source start address is not present in the next descriptor. But will reload the one from configuration memory which belongs to the previous descriptor.";
        SRC_VALID_3 = 3 "Undefined addressing mode";
    };
    
    register dma4_cdpi_0 addr(base, 0xD0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_1 addr(base, 0x130) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_2 addr(base, 0x190) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_3 addr(base, 0x1F0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_4 addr(base, 0x250) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_5 addr(base, 0x2B0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_6 addr(base, 0x310) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_7 addr(base, 0x370) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_8 addr(base, 0x3D0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_9 addr(base, 0x430) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_10 addr(base, 0x490) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_11 addr(base, 0x4F0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_12 addr(base, 0x550) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_13 addr(base, 0x5B0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_14 addr(base, 0x610) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_15 addr(base, 0x670) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_16 addr(base, 0x6D0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_17 addr(base, 0x730) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_18 addr(base, 0x790) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_19 addr(base, 0x7F0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_20 addr(base, 0x850) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_21 addr(base, 0x8B0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_22 addr(base, 0x910) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_23 addr(base, 0x970) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_24 addr(base, 0x9D0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_25 addr(base, 0xA30) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_26 addr(base, 0xA90) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_27 addr(base, 0xAF0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_28 addr(base, 0xB50) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_29 addr(base, 0xBB0) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_30 addr(base, 0xC10) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cdpi_31 addr(base, 0xC70) "This register controls the various parameters of the link list mechanism" {
        _ 21 mbz;
        fast 1 rw type(fast_status) "Sets the fast-start mode for linked list descriptor types 1, 2 and 3";
        transfer_mode 2 rw type(transfer_mode_status) "Enable linked-list transfer mode";
        pause_link_list 1 rw type(pause_link_list_status) "Suspend the linked-list transfer at completion of the current block transfer.";
        next_descriptor_type 3 rw type(next_descriptor_type_status) "Next Descriptor Type";
        src_valid 2 rw type(src_valid_status) "Source address valid";
        dest_valid 2 rw type(src_valid_status) "Destination address valid";
    };
    
    register dma4_cndpi_0 addr(base, 0xD4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_1 addr(base, 0x134) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_2 addr(base, 0x194) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_3 addr(base, 0x1F4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_4 addr(base, 0x254) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_5 addr(base, 0x2B4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_6 addr(base, 0x314) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_7 addr(base, 0x374) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_8 addr(base, 0x3D4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_9 addr(base, 0x434) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_10 addr(base, 0x494) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_11 addr(base, 0x4F4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_12 addr(base, 0x554) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_13 addr(base, 0x5B4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_14 addr(base, 0x614) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_15 addr(base, 0x674) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_16 addr(base, 0x6D4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_17 addr(base, 0x734) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_18 addr(base, 0x794) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_19 addr(base, 0x7F4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_20 addr(base, 0x854) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_21 addr(base, 0x8B4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_22 addr(base, 0x914) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_23 addr(base, 0x974) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_24 addr(base, 0x9D4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_25 addr(base, 0xA34) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_26 addr(base, 0xA94) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_27 addr(base, 0xAF4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_28 addr(base, 0xB54) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_29 addr(base, 0xBB4) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_30 addr(base, 0xC14) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_cndpi_31 addr(base, 0xC74) "This register contains the Next descriptor Address Pointer for the link list Mechanism" {
        next_descriptor_pointer 30 rw "This register contains the Next descriptor Address Pointer for the link list Mechanism";
        _ 2 mbz;
    };
    
    register dma4_ccdni_0 addr(base, 0xD8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_1 addr(base, 0x138) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_2 addr(base, 0x198) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_3 addr(base, 0x1F8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_4 addr(base, 0x258) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_5 addr(base, 0x2B8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_6 addr(base, 0x318) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_7 addr(base, 0x378) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_8 addr(base, 0x3D8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_9 addr(base, 0x438) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_10 addr(base, 0x498) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_11 addr(base, 0x4F8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_12 addr(base, 0x558) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_13 addr(base, 0x5B8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_14 addr(base, 0x618) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_15 addr(base, 0x678) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_16 addr(base, 0x6D8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_17 addr(base, 0x738) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_18 addr(base, 0x798) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_19 addr(base, 0x7F8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_20 addr(base, 0x858) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_21 addr(base, 0x8B8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_22 addr(base, 0x918) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_23 addr(base, 0x978) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_24 addr(base, 0x9D8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_25 addr(base, 0xA38) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_26 addr(base, 0xA98) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_27 addr(base, 0xAF8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_28 addr(base, 0xB58) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_29 addr(base, 0xBB8) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_30 addr(base, 0xC18) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
    
    register dma4_ccdni_31 addr(base, 0xC78) "" {
        _ 16 mbz;
        current_descriptor_nbr 16 rw "This register when read contains the current active descriptor number in the link list. This register is Read/write to allow user initialization.";
    };
};