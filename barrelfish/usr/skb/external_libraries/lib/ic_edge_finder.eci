:- module(ic_edge_finder).
:- export disjunctive / 2.
:- export disjunctive_bools / 3.
:- export cumulative / 4.
:- export cumulative / 5.
:- comment(summary, "Quadratic edge-finder algorithm for disjunctive and cumulative constraints for IC").
:- comment(author, "Joachim Schimpf").
:- comment(copyright, "Cisco Systems, Inc.").
:- comment(date, "$Date: 2006/09/23 01:53:46 $").
:- comment(desc, "\n    This library implements the quadratic edge-finder algorithm for the\n    disjunctive and cumulative scheduling constraints for the IC solver.\n    It provides stronger propagation than the ic_cumulative library, but\n    weaker than the cubic ic_edge_finder3 library for cumulative\n    constraints.  It is however computationally cheaper than the\n    ic_edge_finder3 library.\n\n    Note that the same predicates are implemented in both ic_edge_finder\n    and ic_edge_finder3 libraries.\n").
:- comment(cumulative / 4, [amode : cumulative(+, +, +, ++), args : ["StartTimes" : "List of start times for tasks (integer variables or integers)", "Durations" : "List of duration for tasks (integer variables or integers)", "Resources" : "List of resource uages by tasks (integer variables or integers)", "ResourceLimit" : "Maximum amount of resource available (integer)"], summary : "Cumulative constraint on specified tasks.", see_also : [disjunctive / 2, cumulative / 5, collection_to_list / 2, _123703 : cumulative / 4], desc : html("<P>\n   A cumulative scheduling constraint. StartTimes, Durations and Resources\n   are collections (a la collection_to_list/2) of equal size N of integer\n   variables or integers.  ResourceLimit is an integer. The declarative\n   meaning is:\n   If there are N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time.\n</P><P>\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n</P><P>\n   This constraint can propagate more information than the implementation\n   in library(ic_cumulative) and library(cumulative).\n</P>")]).
:- comment(cumulative / 5, [amode : cumulative(+, +, +, +, ++), args : ["StartTimes" : "Collection of start times for tasks (integer variables or integers)", "Durations" : "Collection of duration for tasks (integer variables or integers)", "Resources" : "Collection of resource usages by tasks (integer variables or integers)", "Areas" : "Collection of areas covered by tasks (integer variables or integers)", "ResourceLimit" : "Maximum amount of resource available (integer)"], summary : "Cumulative constraint on specified tasks.", see_also : [disjunctive / 2, cumulative / 4, collection_to_list / 2, _124925 : cumulative / 5], desc : html("<P>\n   In this variant, an area (the product of duration and resource usage of\n   a task) can be specified, e.g. if duration or reource usage are not\n   known in advance. The edge-finder algorithm can make use of this information\n   to derive bound updates.\n</P><P>\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n</P>\n")]).
:- comment(disjunctive / 2, [amode : disjunctive(+, +), args : ["StartTimes" : "Collection of start times for tasks (integer variables or integers)", "Durations" : "Collection of duration for tasks (integer variables or integers)"], summary : "Constrain the tasks with specified start times and durations to not overlap in time.", see_also : [disjunctive_bools / 3, collection_to_list / 2, _121568 : disjunctive / 2], desc : html("<P>\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n</P><P>\n    Any input variables which do not already have finite bounds will be\n    given default bounds of -10000000 to 10000000.\n</P>")]).
:- comment(disjunctive_bools / 3, [amode : disjunctive_bools(+, +, +), amode : disjunctive_bools(+, +, -), args : ["StartTimes" : "Collection of start times for tasks (integer variables or integers)", "Durations" : "Collection of duration for tasks (integer variables or integers)", "OrderingBools" : "Variable, or list of ordering Booleans (variable or 0 or 1)"], summary : "Constrain the tasks with specified start times and durations to not overlap in time.", see_also : [disjunctive / 2, collection_to_list / 2, _122512 : disjunctive_bools / 3], desc : html("<P>\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n</P><P>\n    OrderingBools is a list of ordering Booleans. For each possible pair of\n    tasks, there is one Boolean which describes the order of these two tasks.\n    If the Tasks are numbered 1..N, and the Booleans are numbered\n    1..N*(N-1)//2, then the Boolean corresponding to the task pair I,J\n    (with I&gt;J) has the index (I-1)(I-2)//2 + J.  In other words, the\n    OrderingBools list is a flattened version of a strictly lower\n    triangular matrix of ordering Booleans, i.e.\n    <PRE>\n        I\\J|  1    2    3    4    5\n        ---+--------------------------\n        1  |  .    .    .    .    .\n        2  | B[1]  .    .    .    .\n        3  | B[2] B[3]  .    .    .\n        4  | B[4] B[5] B[6]  .    .\n        5  | B[7] B[8] B[9] B[10] .\n    </PRE>\n    The Boolean being set to 1 indicates that task I is before task J,\n    a value of 0 indicates that task J is before task I. If uninstantiated,\n    the order is not (yet) determined. Operationally, the constraint will\n    both infer start time bounds from the setting of the Booleans, and\n    infer Boolean settings from the start times and durations.\n</P><P>\n    The Booleans should be used for making search choices, typically by\n    setting them such that a task is chosen to be first (or last) among\n    a group of tasks.\n</P><P>\n    Any Start and Duration variables which do not already have finite bounds\n    will be given default bounds of -10000000 to 10000000. The Booleans on\n    the other hand can be domainless variables, and the only way in which\n    the constraint will affect them is by instantiation to 0 or 1.\n</P>")]).
