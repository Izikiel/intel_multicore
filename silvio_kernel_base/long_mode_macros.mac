;**************************************************************************************
;pushaq:    Emulates the 'pushaq instruction' under long mode. 
;
;  Input:  --
;
;  Output: --
;
;**************************************************************************************
align 8
%macro pushaq 0
   ;Save registers to the stack.
   ;--------------------------------

   push rax      ;save current rax
   push rbx      ;save current rbx
   push rcx      ;save current rcx
   push rdx      ;save current rdx
   push rbp      ;save current rbp
   push rdi      ;save current rdi
   push rsi      ;save current rsi
   push r8         ;save current r8
   push r9         ;save current r9
   push r10      ;save current r10
   push r11      ;save current r11
   push r12      ;save current r12
   push r13      ;save current r13
   push r14      ;save current r14
   push r15      ;save current r15

%endmacro   ;end of macro definition

;**************************************************************************************
;popaq:    Emulates the 'popaq instruction' under long mode. 
;      
;  Input:  --
;
;  Output: --
;
;**************************************************************************************
align 8

%macro popaq 0
   ;Restore registers from the stack.
   ;--------------------------------

   pop r15         ;restore current r15
   pop r14         ;restore current r14
   pop r13         ;restore current r13
   pop r12         ;restore current r12
   pop r11         ;restore current r11
   pop r10         ;restore current r10
   pop r9         ;restore current r9
   pop r8         ;restore current r8
   pop rsi         ;restore current rsi
   pop rdi         ;restore current rdi
   pop rbp         ;restore current rbp
   pop rdx         ;restore current rdx
   pop rcx         ;restore current rcx
   pop rbx         ;restore current rbx
   pop rax         ;restore current rax

%endmacro   ;end of macro definition

%macro enterAlignedStack16 0
push rax;preservo rax original

mov rax, 0xFFFFFFFFFFFFFFF0;64 bits de unos menos los 4 menos significativos
and rax, rsp;pongo mascara
cmp rsp, rax; me fijo si rax es multiplo de 16
je %%alreadyAligned

mov rax, 1;flag de que alinie la pila
sub rsp, 8;alineo
;nota, tener en cuenta que aca debo hacer pushes siempre manteniendo a 16 bytes alineada la pila!
push rax;pusheo flag indicando si hubo que alinear o no(0 no , 1 si)
sub rsp, 8; padding a 16 al rsp
jmp %%code


%%alreadyAligned:
mov rax, 0;flag de que no alinie la pila
;nota, tener en cuenta que aca debo hacer pushes siempre manteniendo a 16 bytes alineada la pila!
sub rsp, 8; padding a 16 al rsp
push rax;pusheo flag indicando si hubo que alinear o no(0 no , 1 si)

;en [rsp+16] tengo el rax original, lo voy a restaurar para el codigo que se ejecute en este entorno
mov rax, [rsp+16];restauro rax original

jmp %%code

%%code:
%endmacro


%macro exitAlignedStack16 0

%%endcode:
add rsp, 8; deshago padding de push a 16
pop rax
cmp rax, 0;si no hubo que alinear salto a finMacroAlinear
je %%finMacroAlinear

add rsp, 8; deshago alineacion porque rax tenia el flag en 1

%%finMacroAlinear:
pop rax;restauro rax original
%endmacro
